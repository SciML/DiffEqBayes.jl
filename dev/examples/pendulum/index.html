<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl</title><meta name="title" content="Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl"/><meta property="og:title" content="Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl"/><meta property="twitter:title" content="Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl"/><meta name="description" content="Documentation for DiffEqBayes.jl."/><meta property="og:description" content="Documentation for DiffEqBayes.jl."/><meta property="twitter:description" content="Documentation for DiffEqBayes.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqBayes/stable/examples/pendulum/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqBayes/stable/examples/pendulum/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqBayes/stable/examples/pendulum/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DiffEqBayes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffEqBayes.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DiffEqBayes.jl: Bayesian Parameter Estimation for Differential Equations</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Bayesian Inference of ODE</a></li><li class="is-active"><a class="tocitem" href>Bayesian Inference of Pendulum Parameters</a><ul class="internal"><li><a class="tocitem" href="#Set-up-simple-pendulum-problem"><span>Set up simple pendulum problem</span></a></li><li><a class="tocitem" href="#Solve-the-model-and-plot"><span>Solve the model and plot</span></a></li><li><a class="tocitem" href="#Create-some-dummy-data-to-use-for-estimation"><span>Create some dummy data to use for estimation</span></a></li><li><a class="tocitem" href="#Perform-Bayesian-Estimation"><span>Perform Bayesian Estimation</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Bayesian Inference of Pendulum Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bayesian Inference of Pendulum Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqBayes.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqBayes.jl/blob/master/docs/src/examples/pendulum.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bayesian-Inference-of-Pendulum-Parameters"><a class="docs-heading-anchor" href="#Bayesian-Inference-of-Pendulum-Parameters">Bayesian Inference of Pendulum Parameters</a><a id="Bayesian-Inference-of-Pendulum-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Inference-of-Pendulum-Parameters" title="Permalink"></a></h1><p>In this tutorial, we will perform Bayesian parameter inference of the parameters of a pendulum.</p><h2 id="Set-up-simple-pendulum-problem"><a class="docs-heading-anchor" href="#Set-up-simple-pendulum-problem">Set up simple pendulum problem</a><a id="Set-up-simple-pendulum-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-simple-pendulum-problem" title="Permalink"></a></h2><pre><code class="language-julia hljs">using DiffEqBayes, OrdinaryDiffEq, RecursiveArrayTools, Distributions, Plots, StatsPlots,
      BenchmarkTools, TransformVariables, StanSample, DynamicHMC</code></pre><p>Let&#39;s define our simple pendulum problem. Here, our pendulum has a drag term <code>ω</code> and a length <code>L</code>.</p><p><img src="https://user-images.githubusercontent.com/1814174/59942945-059c1680-942f-11e9-991c-2025e6e4ccd3.jpg" alt="pendulum"/></p><p>We get first order equations by defining the first term as the velocity and the second term as the position, getting:</p><pre><code class="language-julia hljs">function pendulum(du, u, p, t)
    ω, L = p
    x, y = u
    du[1] = y
    du[2] = -ω * y - (9.8 / L) * sin(x)
end

u0 = [1.0, 0.1]
tspan = (0.0, 10.0)
prob1 = ODEProblem(pendulum, u0, tspan, [1.0, 2.5])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 10.0)
u0: 2-element Vector{Float64}:
 1.0
 0.1</code></pre><h2 id="Solve-the-model-and-plot"><a class="docs-heading-anchor" href="#Solve-the-model-and-plot">Solve the model and plot</a><a id="Solve-the-model-and-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-model-and-plot" title="Permalink"></a></h2><p>To understand the model and generate data, let&#39;s solve and visualize the solution with the known parameters:</p><pre><code class="language-julia hljs">sol = solve(prob1, Tsit5())
plot(sol)</code></pre><img src="0923331f.svg" alt="Example block output"/><p>It&#39;s the pendulum, so you know what it looks like. It&#39;s periodic, but since we have not made a small angle assumption, it&#39;s not exactly <code>sin</code> or <code>cos</code>. Because the true dampening parameter <code>ω</code> is 1, the solution does not decay over time, nor does it increase. The length <code>L</code> determines the period.</p><h2 id="Create-some-dummy-data-to-use-for-estimation"><a class="docs-heading-anchor" href="#Create-some-dummy-data-to-use-for-estimation">Create some dummy data to use for estimation</a><a id="Create-some-dummy-data-to-use-for-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Create-some-dummy-data-to-use-for-estimation" title="Permalink"></a></h2><p>We now generate some dummy data to use for estimation</p><pre><code class="language-julia hljs">t = collect(range(1, stop = 10, length = 10))
randomized = VectorOfArray([(sol(t[i]) + 0.01randn(2)) for i in 1:length(t)])
data = convert(Array, randomized)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×10 Matrix{Float64}:
  0.0811864  -0.373212  0.103455  …  -0.00501684  -0.0110172  0.0186969
 -1.23487     0.356423  0.315357     -0.0257028    0.0198784  0.00702587</code></pre><p>Let&#39;s see what our data looks like on top of the real solution</p><pre><code class="language-julia hljs">scatter!(data&#39;)</code></pre><img src="c0ed57aa.svg" alt="Example block output"/><p>This data captures the non-dampening effect and the true period, making it perfect for attempting a Bayesian inference.</p><h2 id="Perform-Bayesian-Estimation"><a class="docs-heading-anchor" href="#Perform-Bayesian-Estimation">Perform Bayesian Estimation</a><a id="Perform-Bayesian-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Perform-Bayesian-Estimation" title="Permalink"></a></h2><p>Now let&#39;s fit the pendulum to the data. Since we know our model is correct, this should give us back the parameters that we used to generate the data! Define priors on our parameters. In this case, let&#39;s assume we don&#39;t have much information, but have a prior belief that ω is between 0.1 and 3.0, while the length of the pendulum L is probably around 3.0:</p><pre><code class="language-julia hljs">priors = [
    truncated(Normal(0.1, 1.0), lower = 0.0),
    truncated(Normal(3.0, 1.0), lower = 0.0)
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64, Float64, Nothing}}:
 Truncated(Distributions.Normal{Float64}(μ=0.1, σ=1.0); lower=0.0)
 Truncated(Distributions.Normal{Float64}(μ=3.0, σ=1.0); lower=0.0)</code></pre><p>Finally, let&#39;s run the estimation routine from DiffEqBayes.jl with the Turing.jl backend to check if we indeed recover the parameters!</p><pre><code class="language-julia hljs">bayesian_result = turing_inference(prob1, Tsit5(), t, data, priors;
    syms = [:omega, :L], sample_args = (num_samples = 10_000,))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (10000×17×1 Array{Float64, 3}):

Iterations        = 1001:1:11000
Number of chains  = 1
Samples per chain = 10000
Wall duration     = 60.0 seconds
Compute duration  = 60.0 seconds
parameters        = omega, L, σ[1]
internals         = n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size, logprior, loglikelihood, logjoint

Summary Statistics
 <span class="sgr1"> parameters </span> <span class="sgr1">    mean </span> <span class="sgr1">     std </span> <span class="sgr1">    mcse </span> <span class="sgr1">  ess_bulk </span> <span class="sgr1">  ess_tail </span> <span class="sgr1">    rhat </span>  ⋯
 <span class="sgr90">     Symbol </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90">   Float64 </span> <span class="sgr90">   Float64 </span> <span class="sgr90"> Float64 </span>  ⋯

       omega    1.0354    0.1737    0.0025   5199.9261   5137.8788    1.0001   ⋯
           L    2.5199    0.2013    0.0027   5795.6859   5226.5007    1.0000   ⋯
        σ[1]    0.1584    0.0372    0.0005   5308.3447   4812.3171    0.9999   ⋯
<span class="sgr36">                                                                1 column omitted</span>

Quantiles
 <span class="sgr1"> parameters </span> <span class="sgr1">    2.5% </span> <span class="sgr1">   25.0% </span> <span class="sgr1">   50.0% </span> <span class="sgr1">   75.0% </span> <span class="sgr1">   97.5% </span>
 <span class="sgr90">     Symbol </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span>

       omega    0.7520    0.9173    1.0153    1.1297    1.4376
           L    2.1340    2.3947    2.5153    2.6391    2.9348
        σ[1]    0.1006    0.1320    0.1531    0.1793    0.2442
</code></pre><p>Notice that while our guesses had the wrong means, the learned parameters converged to the correct means, meaning that it learned good posterior distributions for the parameters. To look at these posterior distributions on the parameters, we can examine the chains:</p><pre><code class="language-julia hljs">plot(bayesian_result)</code></pre><img src="22f61e5d.svg" alt="Example block output"/><p>As a diagnostic, we will also check the parameter chains. The chain is the MCMC sampling process. The chain should explore parameter space and converge reasonably well, and we should be taking a lot of samples after it converges (it is these samples that form the posterior distribution!)</p><pre><code class="language-julia hljs">plot(bayesian_result, colordim = :parameter)</code></pre><img src="42384391.svg" alt="Example block output"/><p>Notice that after a while these chains converge to a “fuzzy line”, meaning it found the area with the most likelihood and then starts to sample around there, which builds a posterior distribution around the true mean.</p><p>DiffEqBayes.jl allows the choice of using Stan.jl, Turing.jl and DynamicHMC.jl for MCMC, you can also use ApproxBayes.jl for Approximate Bayesian computation algorithms. Let&#39;s compare the timings across the different MCMC backends. We&#39;ll stick with the default arguments and 10,000 samples in each. However, there is a lot of room for micro-optimization specific to each package and algorithm combinations, you might want to do your own experiments for specific problems to get better understanding of the performance.</p><pre><code class="language-julia hljs">@btime bayesian_result = turing_inference(prob1, Tsit5(), t, data, priors;
    syms = [:omega, :L], sample_args = (num_samples = 10_000,))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (10000×17×1 Array{Float64, 3}):

Iterations        = 1001:1:11000
Number of chains  = 1
Samples per chain = 10000
Wall duration     = 52.88 seconds
Compute duration  = 52.88 seconds
parameters        = omega, L, σ[1]
internals         = n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size, logprior, loglikelihood, logjoint

Summary Statistics
 <span class="sgr1"> parameters </span> <span class="sgr1">    mean </span> <span class="sgr1">     std </span> <span class="sgr1">    mcse </span> <span class="sgr1">  ess_bulk </span> <span class="sgr1">  ess_tail </span> <span class="sgr1">    rhat </span>  ⋯
 <span class="sgr90">     Symbol </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90">   Float64 </span> <span class="sgr90">   Float64 </span> <span class="sgr90"> Float64 </span>  ⋯

       omega    1.0399    0.1770    0.0027   5131.7882   4470.3211    1.0000   ⋯
           L    2.5140    0.2044    0.0030   4884.4110   4438.4069    1.0004   ⋯
        σ[1]    0.1595    0.0374    0.0005   5819.2331   5483.1958    1.0003   ⋯
<span class="sgr36">                                                                1 column omitted</span>

Quantiles
 <span class="sgr1"> parameters </span> <span class="sgr1">    2.5% </span> <span class="sgr1">   25.0% </span> <span class="sgr1">   50.0% </span> <span class="sgr1">   75.0% </span> <span class="sgr1">   97.5% </span>
 <span class="sgr90">     Symbol </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span>

       omega    0.7536    0.9234    1.0183    1.1328    1.4375
           L    2.1127    2.3845    2.5081    2.6385    2.9380
        σ[1]    0.1025    0.1330    0.1538    0.1793    0.2492
</code></pre><pre><code class="language-julia hljs">@btime bayesian_result = stan_inference(prob1, :rk45, t, data, priors;
    sample_kwargs = Dict(:num_samples =&gt; 10_000), print_summary = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (10000×4×1 Array{Float64, 3}):

Iterations        = 1:1:10000
Number of chains  = 1
Samples per chain = 10000
parameters        = sigma1.1, sigma1.2, theta_1, theta_2
internals         = 

Summary Statistics
 <span class="sgr1"> parameters </span> <span class="sgr1">    mean </span> <span class="sgr1">     std </span> <span class="sgr1">    mcse </span> <span class="sgr1">  ess_bulk </span> <span class="sgr1">  ess_tail </span> <span class="sgr1">    rhat </span>  ⋯
 <span class="sgr90">     Symbol </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90">   Float64 </span> <span class="sgr90">   Float64 </span> <span class="sgr90"> Float64 </span>  ⋯

    sigma1.1    0.2603    0.0769    0.0009   8637.9711   6675.1234    1.0005   ⋯
    sigma1.2    0.2818    0.0893    0.0011   7826.3737   6302.8850    1.0006   ⋯
     theta_1    1.0830    0.2939    0.0039   7024.9389   5271.8073    1.0000   ⋯
     theta_2    2.5731    0.3517    0.0044   6573.3257   5371.9265    0.9999   ⋯
<span class="sgr36">                                                                1 column omitted</span>

Quantiles
 <span class="sgr1"> parameters </span> <span class="sgr1">    2.5% </span> <span class="sgr1">   25.0% </span> <span class="sgr1">   50.0% </span> <span class="sgr1">   75.0% </span> <span class="sgr1">   97.5% </span>
 <span class="sgr90">     Symbol </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span> <span class="sgr90"> Float64 </span>

    sigma1.1    0.1489    0.2058    0.2477    0.2993    0.4488
    sigma1.2    0.1563    0.2190    0.2659    0.3263    0.4991
     theta_1    0.6536    0.8821    1.0348    1.2264    1.8126
     theta_2    1.9297    2.3503    2.5522    2.7627    3.3431
</code></pre><pre><code class="language-julia hljs">@btime bayesian_result = dynamichmc_inference(prob1, Tsit5(), t, data, priors;
    num_samples = 10_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(posterior = [(parameters = [0.9946201867900494, 2.4837525889491636], σ = [0.011231626572210175, 0.006908546022182958]), (parameters = [0.9970975967125545, 2.4855225740466236], σ = [0.01976427950209412, 0.006913896414407506]), (parameters = [1.0031568862395561, 2.517905306366809], σ = [0.0131605501418826, 0.010476291007693114]), (parameters = [0.9908137764619509, 2.4976538982350287], σ = [0.016099400707919275, 0.01652579696393724]), (parameters = [0.9935164396840576, 2.5051989430908397], σ = [0.015253286619040747, 0.017287985274249757]), (parameters = [0.9950761288918418, 2.505099669761025], σ = [0.015507304880563785, 0.012664091977099065]), (parameters = [0.9992463572474082, 2.4930639764294242], σ = [0.02131645536107704, 0.010216409178507893]), (parameters = [1.0041494966606264, 2.486006826798923], σ = [0.0225828561958482, 0.012312311483858711]), (parameters = [0.9857986559869738, 2.4894674661166176], σ = [0.01946175687861944, 0.007417211642075163]), (parameters = [0.9893794542222035, 2.4936168618837504], σ = [0.02142992053669113, 0.005554308955594415])  …  (parameters = [0.9785571814894625, 2.516782767870293], σ = [0.026016491768284442, 0.011983727241212409]), (parameters = [0.9776468424131834, 2.501882843582948], σ = [0.0186965876557453, 0.015495574330103212]), (parameters = [0.9847457286644403, 2.5003034595932543], σ = [0.01770884503358724, 0.012802285388907951]), (parameters = [0.9787241872150625, 2.5017433724255937], σ = [0.014816849204114357, 0.006694722808451269]), (parameters = [0.990590673397348, 2.508130880845397], σ = [0.020240166154887284, 0.009806281354408348]), (parameters = [0.9838217392017811, 2.4939985592528315], σ = [0.014867469286613163, 0.0076275340926479284]), (parameters = [0.9926812060951465, 2.4881501064929457], σ = [0.02064643425765188, 0.0074123454883031625]), (parameters = [1.0014701073025696, 2.4754145786661392], σ = [0.013414570473598258, 0.007226540609859997]), (parameters = [1.0085652105493947, 2.479752470669422], σ = [0.015150072615995625, 0.009788756653633999]), (parameters = [0.9822691472081772, 2.492977460553061], σ = [0.016632181734792865, 0.018734987664555797])], posterior_matrix = [-0.005394336516909484 -0.0029066234275441074 … 0.008528737253178762 -0.01788992752085551; 0.9097705572383191 0.9104829288073124 … 0.9081587449815772 0.9134777634067115; -4.489021679027528 -3.9238790361185596 … -4.189749953903221 -4.096415801670775; -4.974996079814562 -4.974221919601371 … -4.626520832176819 -3.977362505153794], tree_statistics = DynamicHMC.TreeStatisticsNUTS[DynamicHMC.TreeStatisticsNUTS(44.165355392046806, 3, turning at positions -3:4, 0.9508941943217203, 7, DynamicHMC.Directions(0x331af84c)), DynamicHMC.TreeStatisticsNUTS(44.73361333534089, 3, turning at positions -5:2, 0.9335326931059519, 7, DynamicHMC.Directions(0x58fa2f82)), DynamicHMC.TreeStatisticsNUTS(41.667550436065284, 3, turning at positions -7:0, 0.6107427991422194, 7, DynamicHMC.Directions(0x649ae9e0)), DynamicHMC.TreeStatisticsNUTS(42.68101808849774, 3, turning at positions -7:0, 0.9999999999999999, 7, DynamicHMC.Directions(0x9651e100)), DynamicHMC.TreeStatisticsNUTS(43.113187777084725, 2, turning at positions -2:-5, 0.9646832744446205, 7, DynamicHMC.Directions(0x72dbf2ba)), DynamicHMC.TreeStatisticsNUTS(42.80867109838134, 1, turning at positions -1:-2, 0.9763510725482663, 3, DynamicHMC.Directions(0xabb3d2c1)), DynamicHMC.TreeStatisticsNUTS(44.16737269092234, 2, turning at positions -3:-6, 0.9526660120067397, 7, DynamicHMC.Directions(0x802ddf69)), DynamicHMC.TreeStatisticsNUTS(45.01187430209982, 3, turning at positions -2:5, 0.9918022296781082, 7, DynamicHMC.Directions(0xe62adb5d)), DynamicHMC.TreeStatisticsNUTS(42.36133408449443, 3, turning at positions 0:7, 0.9726620944627976, 7, DynamicHMC.Directions(0xb57983ef)), DynamicHMC.TreeStatisticsNUTS(46.35984283631718, 2, turning at positions 0:3, 0.9100040556850323, 3, DynamicHMC.Directions(0x0a0955b7))  …  DynamicHMC.TreeStatisticsNUTS(41.393049363762174, 3, turning at positions -7:0, 0.6586830324304548, 7, DynamicHMC.Directions(0xc4f44ba8)), DynamicHMC.TreeStatisticsNUTS(42.06576983524012, 3, turning at positions -4:3, 0.946955653727076, 7, DynamicHMC.Directions(0x29188523)), DynamicHMC.TreeStatisticsNUTS(44.06401675247547, 2, turning at positions 0:3, 0.9999999999999999, 3, DynamicHMC.Directions(0x62a39d87)), DynamicHMC.TreeStatisticsNUTS(44.84152325884449, 3, turning at positions -4:3, 0.9997758254526383, 7, DynamicHMC.Directions(0x74f85ffb)), DynamicHMC.TreeStatisticsNUTS(44.436416051274136, 3, turning at positions -2:5, 0.8112712273401029, 7, DynamicHMC.Directions(0xbdc220c5)), DynamicHMC.TreeStatisticsNUTS(45.18991313172473, 2, turning at positions -3:-6, 0.9780499130308765, 7, DynamicHMC.Directions(0x430f6e01)), DynamicHMC.TreeStatisticsNUTS(46.442943860375365, 3, turning at positions -6:1, 0.9722995269093548, 7, DynamicHMC.Directions(0x78141401)), DynamicHMC.TreeStatisticsNUTS(43.32115740108737, 3, turning at positions -5:2, 0.7936578853877911, 7, DynamicHMC.Directions(0x36874b6a)), DynamicHMC.TreeStatisticsNUTS(45.594181317475, 3, turning at positions -3:4, 0.9999999999999999, 7, DynamicHMC.Directions(0xdc8e6074)), DynamicHMC.TreeStatisticsNUTS(41.59643565258131, 2, turning at positions 1:4, 0.7241842654097859, 7, DynamicHMC.Directions(0x0fa6d31c))], logdensities = [46.51011569176091, 47.68724634290027, 43.944134687179414, 44.563567916034515, 44.302819775948585, 46.127329955085195, 46.56958569816752, 45.295909076190505, 47.911614688226166, 47.319849392995195  …  43.809399206581524, 44.11109858366453, 45.919961516997084, 46.961011936179645, 46.30777818031256, 47.878139710854086, 47.91705445314073, 46.476340328606724, 46.742523519391106, 42.954280309808354], κ = Gaussian kinetic energy (Diagonal), √diag(M⁻¹): [0.011912568378284506, 0.004864618050880494, 0.23303115030740645, 0.30941375054251674], ϵ = 0.4507909230680425)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Bayesian Inference of ODE</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 12 January 2026 16:52">Monday 12 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
