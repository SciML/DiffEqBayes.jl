<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl</title><meta name="title" content="Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl"/><meta property="og:title" content="Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl"/><meta property="twitter:title" content="Bayesian Inference of Pendulum Parameters · DiffEqBayes.jl"/><meta name="description" content="Documentation for DiffEqBayes.jl."/><meta property="og:description" content="Documentation for DiffEqBayes.jl."/><meta property="twitter:description" content="Documentation for DiffEqBayes.jl."/><meta property="og:url" content="https://docs.sciml.ai/DiffEqBayes/stable/examples/pendulum/"/><meta property="twitter:url" content="https://docs.sciml.ai/DiffEqBayes/stable/examples/pendulum/"/><link rel="canonical" href="https://docs.sciml.ai/DiffEqBayes/stable/examples/pendulum/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="DiffEqBayes.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">DiffEqBayes.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">DiffEqBayes.jl: Bayesian Parameter Estimation for Differential Equations</a></li><li><a class="tocitem" href="../../methods/">Methods</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../">Bayesian Inference of ODE</a></li><li class="is-active"><a class="tocitem" href>Bayesian Inference of Pendulum Parameters</a><ul class="internal"><li><a class="tocitem" href="#Set-up-simple-pendulum-problem"><span>Set up simple pendulum problem</span></a></li><li><a class="tocitem" href="#Solve-the-model-and-plot"><span>Solve the model and plot</span></a></li><li><a class="tocitem" href="#Create-some-dummy-data-to-use-for-estimation"><span>Create some dummy data to use for estimation</span></a></li><li><a class="tocitem" href="#Perform-Bayesian-Estimation"><span>Perform Bayesian Estimation</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Bayesian Inference of Pendulum Parameters</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Bayesian Inference of Pendulum Parameters</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqBayes.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/DiffEqBayes.jl/blob/master/docs/src/examples/pendulum.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Bayesian-Inference-of-Pendulum-Parameters"><a class="docs-heading-anchor" href="#Bayesian-Inference-of-Pendulum-Parameters">Bayesian Inference of Pendulum Parameters</a><a id="Bayesian-Inference-of-Pendulum-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Inference-of-Pendulum-Parameters" title="Permalink"></a></h1><p>In this tutorial, we will perform Bayesian parameter inference of the parameters of a pendulum.</p><h2 id="Set-up-simple-pendulum-problem"><a class="docs-heading-anchor" href="#Set-up-simple-pendulum-problem">Set up simple pendulum problem</a><a id="Set-up-simple-pendulum-problem-1"></a><a class="docs-heading-anchor-permalink" href="#Set-up-simple-pendulum-problem" title="Permalink"></a></h2><pre><code class="language-julia hljs">using DiffEqBayes, OrdinaryDiffEq, RecursiveArrayTools, Distributions, Plots, StatsPlots,
      BenchmarkTools, TransformVariables, StanSample, DynamicHMC</code></pre><p>Let&#39;s define our simple pendulum problem. Here, our pendulum has a drag term <code>ω</code> and a length <code>L</code>.</p><p><img src="https://user-images.githubusercontent.com/1814174/59942945-059c1680-942f-11e9-991c-2025e6e4ccd3.jpg" alt="pendulum"/></p><p>We get first order equations by defining the first term as the velocity and the second term as the position, getting:</p><pre><code class="language-julia hljs">function pendulum(du, u, p, t)
    ω, L = p
    x, y = u
    du[1] = y
    du[2] = -ω * y - (9.8 / L) * sin(x)
end

u0 = [1.0, 0.1]
tspan = (0.0, 10.0)
prob1 = ODEProblem(pendulum, u0, tspan, [1.0, 2.5])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
Non-trivial mass matrix: <span class="sgr38_2" style="color:#56b6c2">false</span>
timespan: (0.0, 10.0)
u0: 2-element Vector{Float64}:
 1.0
 0.1</code></pre><h2 id="Solve-the-model-and-plot"><a class="docs-heading-anchor" href="#Solve-the-model-and-plot">Solve the model and plot</a><a id="Solve-the-model-and-plot-1"></a><a class="docs-heading-anchor-permalink" href="#Solve-the-model-and-plot" title="Permalink"></a></h2><p>To understand the model and generate data, let&#39;s solve and visualize the solution with the known parameters:</p><pre><code class="language-julia hljs">sol = solve(prob1, Tsit5())
plot(sol)</code></pre><img src="1c29e308.svg" alt="Example block output"/><p>It&#39;s the pendulum, so you know what it looks like. It&#39;s periodic, but since we have not made a small angle assumption, it&#39;s not exactly <code>sin</code> or <code>cos</code>. Because the true dampening parameter <code>ω</code> is 1, the solution does not decay over time, nor does it increase. The length <code>L</code> determines the period.</p><h2 id="Create-some-dummy-data-to-use-for-estimation"><a class="docs-heading-anchor" href="#Create-some-dummy-data-to-use-for-estimation">Create some dummy data to use for estimation</a><a id="Create-some-dummy-data-to-use-for-estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Create-some-dummy-data-to-use-for-estimation" title="Permalink"></a></h2><p>We now generate some dummy data to use for estimation</p><pre><code class="language-julia hljs">t = collect(range(1, stop = 10, length = 10))
randomized = VectorOfArray([(sol(t[i]) + 0.01randn(2)) for i in 1:length(t)])
data = convert(Array, randomized)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×10 Matrix{Float64}:
  0.0383556  -0.39711   0.10529    0.0888528  …  -0.00167653  0.00423734
 -1.21637     0.341748  0.319378  -0.245366       0.0202929   0.0121386</code></pre><p>Let&#39;s see what our data looks like on top of the real solution</p><pre><code class="language-julia hljs">scatter!(data&#39;)</code></pre><img src="df742c5d.svg" alt="Example block output"/><p>This data captures the non-dampening effect and the true period, making it perfect for attempting a Bayesian inference.</p><h2 id="Perform-Bayesian-Estimation"><a class="docs-heading-anchor" href="#Perform-Bayesian-Estimation">Perform Bayesian Estimation</a><a id="Perform-Bayesian-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Perform-Bayesian-Estimation" title="Permalink"></a></h2><p>Now let&#39;s fit the pendulum to the data. Since we know our model is correct, this should give us back the parameters that we used to generate the data! Define priors on our parameters. In this case, let&#39;s assume we don&#39;t have much information, but have a prior belief that ω is between 0.1 and 3.0, while the length of the pendulum L is probably around 3.0:</p><pre><code class="language-julia hljs">priors = [
    truncated(Normal(0.1, 1.0), lower = 0.0),
    truncated(Normal(3.0, 1.0), lower = 0.0)
]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2-element Vector{Distributions.Truncated{Distributions.Normal{Float64}, Distributions.Continuous, Float64, Float64, Nothing}}:
 Truncated(Distributions.Normal{Float64}(μ=0.1, σ=1.0); lower=0.0)
 Truncated(Distributions.Normal{Float64}(μ=3.0, σ=1.0); lower=0.0)</code></pre><p>Finally, let&#39;s run the estimation routine from DiffEqBayes.jl with the Turing.jl backend to check if we indeed recover the parameters!</p><pre><code class="language-julia hljs">bayesian_result = turing_inference(prob1, Tsit5(), t, data, priors;
    syms = [:omega, :L], sample_args = (num_samples = 10_000,))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (10000×17×1 Array{Float64, 3}):

Iterations        = 1001:1:11000
Number of chains  = 1
Samples per chain = 10000
Wall duration     = 67.95 seconds
Compute duration  = 67.95 seconds
parameters        = omega, L, σ[1]
internals         = n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size, logprior, loglikelihood, logjoint

Summary Statistics
 <span class="sgr1"> parameters      mean       std      mcse    ess_bulk    ess_tail      rhat   ⋯
 <span class="sgr90">     Symbol   Float64   Float64   Float64     Float64     Float64   Float64   ⋯

       omega    1.0323    0.1793    0.0025   5879.2745   4917.6213    0.9999   ⋯
           L    2.5387    0.2081    0.0028   5608.9780   5105.2194    1.0002   ⋯
        σ[1]    0.1589    0.0374    0.0006   3910.3328   3700.8811    1.0004   ⋯
</span><span class="sgr36">                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
 </span><span class="sgr90">     Symbol   Float64   Float64   Float64   Float64   Float64

       omega    0.7482    0.9135    1.0090    1.1257    1.4563
           L    2.1431    2.4086    2.5341    2.6611    2.9610
        σ[1]    0.1017    0.1324    0.1541    0.1794    0.2461
</span></span></code></pre><p>Notice that while our guesses had the wrong means, the learned parameters converged to the correct means, meaning that it learned good posterior distributions for the parameters. To look at these posterior distributions on the parameters, we can examine the chains:</p><pre><code class="language-julia hljs">plot(bayesian_result)</code></pre><img src="fec92352.svg" alt="Example block output"/><p>As a diagnostic, we will also check the parameter chains. The chain is the MCMC sampling process. The chain should explore parameter space and converge reasonably well, and we should be taking a lot of samples after it converges (it is these samples that form the posterior distribution!)</p><pre><code class="language-julia hljs">plot(bayesian_result, colordim = :parameter)</code></pre><img src="c0198220.svg" alt="Example block output"/><p>Notice that after a while these chains converge to a “fuzzy line”, meaning it found the area with the most likelihood and then starts to sample around there, which builds a posterior distribution around the true mean.</p><p>DiffEqBayes.jl allows the choice of using Stan.jl, Turing.jl and DynamicHMC.jl for MCMC, you can also use ApproxBayes.jl for Approximate Bayesian computation algorithms. Let&#39;s compare the timings across the different MCMC backends. We&#39;ll stick with the default arguments and 10,000 samples in each. However, there is a lot of room for micro-optimization specific to each package and algorithm combinations, you might want to do your own experiments for specific problems to get better understanding of the performance.</p><pre><code class="language-julia hljs">@btime bayesian_result = turing_inference(prob1, Tsit5(), t, data, priors;
    syms = [:omega, :L], sample_args = (num_samples = 10_000,))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (10000×17×1 Array{Float64, 3}):

Iterations        = 1001:1:11000
Number of chains  = 1
Samples per chain = 10000
Wall duration     = 134.47 seconds
Compute duration  = 134.47 seconds
parameters        = omega, L, σ[1]
internals         = n_steps, is_accept, acceptance_rate, log_density, hamiltonian_energy, hamiltonian_energy_error, max_hamiltonian_energy_error, tree_depth, numerical_error, step_size, nom_step_size, logprior, loglikelihood, logjoint

Summary Statistics
 <span class="sgr1"> parameters      mean       std      mcse   ess_bulk    ess_tail      rhat    ⋯
 <span class="sgr90">     Symbol   Float64   Float64   Float64    Float64     Float64   Float64    ⋯

       omega    3.1216    0.4562    0.0314   291.5661     94.7179    1.0058    ⋯
           L    0.1319    0.0186    0.0008   261.9383     91.4047    1.0057    ⋯
        σ[1]    0.2568    0.0561    0.0024   748.3743   3468.7168    1.0017    ⋯
</span><span class="sgr36">                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
 </span><span class="sgr90">     Symbol   Float64   Float64   Float64   Float64   Float64

       omega    1.9195    2.8529    3.1649    3.4267    3.9414
           L    0.1076    0.1183    0.1279    0.1415    0.1785
        σ[1]    0.1718    0.2172    0.2482    0.2871    0.3841
</span></span></code></pre><pre><code class="language-julia hljs">@btime bayesian_result = stan_inference(prob1, :rk45, t, data, priors;
    sample_kwargs = Dict(:num_samples =&gt; 10_000), print_summary = false)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Chains MCMC chain (10000×4×1 Array{Float64, 3}):

Iterations        = 1:1:10000
Number of chains  = 1
Samples per chain = 10000
parameters        = sigma1.1, sigma1.2, theta_1, theta_2
internals         = 

Summary Statistics
 <span class="sgr1"> parameters      mean       std      mcse    ess_bulk    ess_tail      rhat   ⋯
 <span class="sgr90">     Symbol   Float64   Float64   Float64     Float64     Float64   Float64   ⋯

    sigma1.1    0.2595    0.0782    0.0009   9679.9028   5726.5172    0.9999   ⋯
    sigma1.2    0.2792    0.0860    0.0011   6581.1997   6453.4507    1.0000   ⋯
     theta_1    1.0579    0.2788    0.0036   6722.6029   6024.2993    1.0005   ⋯
     theta_2    2.6001    0.3401    0.0042   7011.6466   6083.6370    1.0002   ⋯
</span><span class="sgr36">                                                                1 column omitted

Quantiles
  parameters      2.5%     25.0%     50.0%     75.0%     97.5%
 </span><span class="sgr90">     Symbol   Float64   Float64   Float64   Float64   Float64

    sigma1.1    0.1492    0.2051    0.2457    0.2982    0.4534
    sigma1.2    0.1568    0.2195    0.2639    0.3218    0.4914
     theta_1    0.6391    0.8675    1.0119    1.1949    1.7488
     theta_2    1.9714    2.3865    2.5774    2.7907    3.3567
</span></span></code></pre><pre><code class="language-julia hljs">@btime bayesian_result = dynamichmc_inference(prob1, Tsit5(), t, data, priors;
    num_samples = 10_000)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">(posterior = [(parameters = [0.9887673816725708, 2.5288916556753134], σ = [0.010936095358902538, 0.027495879909084454]), (parameters = [0.990062434456916, 2.5091994132117055], σ = [0.012409509674370824, 0.015272191982362893]), (parameters = [1.0058679140084863, 2.5284104798992915], σ = [0.010684174475621309, 0.013808162077982805]), (parameters = [1.002213022222881, 2.518333644228519], σ = [0.0182183853515709, 0.010425811214349805]), (parameters = [0.9845468302104042, 2.5221890212999556], σ = [0.011890653252298026, 0.010702004610685887]), (parameters = [0.9889511391442117, 2.5177213998202794], σ = [0.010401743006047183, 0.010102966931141221]), (parameters = [0.9926515687867302, 2.5218069254571986], σ = [0.017950444947976193, 0.010667711952328636]), (parameters = [0.9916580170242987, 2.505792092437459], σ = [0.021430887352195418, 0.009654720566132539]), (parameters = [1.0034571425067367, 2.501126936372605], σ = [0.026729910687960903, 0.010120164443862746]), (parameters = [1.012224041502204, 2.52630734322407], σ = [0.013381410014570536, 0.010708460680683067])  …  (parameters = [0.9883825564770348, 2.51957329652501], σ = [0.016894872240705194, 0.00840995235180096]), (parameters = [1.0147809360648712, 2.51699320697729], σ = [0.019544972990956512, 0.013142190775044594]), (parameters = [0.9882651278775555, 2.5445151438978644], σ = [0.018902057920547253, 0.008085772580053375]), (parameters = [1.0034853237040509, 2.501556871302452], σ = [0.010544780620065673, 0.013431915066903652]), (parameters = [0.9854947983192505, 2.5270547209312633], σ = [0.01978811379098868, 0.013506030295226436]), (parameters = [0.9629779191805184, 2.5160398990203934], σ = [0.01409531571830872, 0.015818222123515524]), (parameters = [0.9820061457348606, 2.55306534066688], σ = [0.01924749734443938, 0.016322141429264712]), (parameters = [0.9863684834073746, 2.5480968265156485], σ = [0.01913138270639085, 0.021487837380119792]), (parameters = [0.9861164608995658, 2.5436492886082416], σ = [0.01589230021456612, 0.019573337347305184]), (parameters = [0.9901880881410297, 2.5074603117590493], σ = [0.01481756838651749, 0.007938986178538316])], posterior_matrix = [-0.011296180613504736 -0.009987272734025802 … -0.013980816851868045 -0.009860365877697846; 0.9277811259932728 0.9199637433856914 … 0.9335997777230762 0.919270412915751; -4.515686459874425 -4.389292191072305 … -4.1419205502840954 -4.211941749059515; -3.5937191070218097 -4.1817216217653295 … -3.933586978270514 -4.835969697198188], tree_statistics = DynamicHMC.TreeStatisticsNUTS[DynamicHMC.TreeStatisticsNUTS(39.916533217118335, 3, turning at positions -6:1, 0.7259758855060169, 7, DynamicHMC.Directions(0x2d47af51)), DynamicHMC.TreeStatisticsNUTS(40.73557239005795, 3, turning at positions -5:2, 0.9790742039111983, 7, DynamicHMC.Directions(0xc549d33a)), DynamicHMC.TreeStatisticsNUTS(43.08961572438472, 2, turning at positions -3:-6, 0.8488889803237073, 7, DynamicHMC.Directions(0x8c2d6551)), DynamicHMC.TreeStatisticsNUTS(43.826335990855135, 3, turning at positions 0:7, 0.9999999999999999, 7, DynamicHMC.Directions(0xaa452c5f)), DynamicHMC.TreeStatisticsNUTS(45.286391030516356, 3, turning at positions -1:6, 0.9914870468177132, 7, DynamicHMC.Directions(0xeeb111ae)), DynamicHMC.TreeStatisticsNUTS(45.32242905271236, 3, turning at positions -5:2, 0.9212219651236625, 7, DynamicHMC.Directions(0xddf9562a)), DynamicHMC.TreeStatisticsNUTS(44.77424096032924, 3, turning at positions -6:1, 0.9589407617262534, 7, DynamicHMC.Directions(0xaa5a7d99)), DynamicHMC.TreeStatisticsNUTS(42.598612123553195, 3, turning at positions -5:2, 0.7236815888864315, 7, DynamicHMC.Directions(0x5e613692)), DynamicHMC.TreeStatisticsNUTS(40.623190109433295, 2, turning at positions -2:-5, 0.9398537670369737, 7, DynamicHMC.Directions(0xcc89292a)), DynamicHMC.TreeStatisticsNUTS(40.85501097580104, 2, turning at positions -1:-4, 0.9598504617069684, 7, DynamicHMC.Directions(0xd8a4da4b))  …  DynamicHMC.TreeStatisticsNUTS(42.720166368413935, 2, turning at positions -1:2, 0.8419818815218284, 3, DynamicHMC.Directions(0xf94474a6)), DynamicHMC.TreeStatisticsNUTS(42.675220710001845, 3, turning at positions -3:4, 0.9446323554349956, 7, DynamicHMC.Directions(0xbc5e6a5c)), DynamicHMC.TreeStatisticsNUTS(40.41513651018383, 2, turning at positions -2:-5, 0.944344495810759, 7, DynamicHMC.Directions(0x887834aa)), DynamicHMC.TreeStatisticsNUTS(43.56862628014646, 3, turning at positions -7:0, 0.9999999999999999, 7, DynamicHMC.Directions(0x646e2c50)), DynamicHMC.TreeStatisticsNUTS(41.26515274980054, 3, turning at positions -7:0, 0.9197783320630165, 7, DynamicHMC.Directions(0x62e76a30)), DynamicHMC.TreeStatisticsNUTS(41.519609988107675, 3, turning at positions -5:2, 0.865682206106251, 7, DynamicHMC.Directions(0x91411822)), DynamicHMC.TreeStatisticsNUTS(41.24684895283393, 3, turning at positions -5:2, 0.97775745763607, 7, DynamicHMC.Directions(0xba7ad03a)), DynamicHMC.TreeStatisticsNUTS(41.551462926996706, 2, turning at positions -2:1, 0.9632242036121679, 3, DynamicHMC.Directions(0x80279739)), DynamicHMC.TreeStatisticsNUTS(41.84095884931631, 2, turning at positions 0:3, 0.9999999999999999, 3, DynamicHMC.Directions(0x9312794b)), DynamicHMC.TreeStatisticsNUTS(41.221167075873694, 3, turning at positions -2:5, 0.9435185378797037, 7, DynamicHMC.Directions(0x929780b5))], logdensities = [41.305410055279154, 45.46456001201027, 43.91654278948477, 45.990893278065215, 46.301306993099175, 45.95909755464035, 46.11438215022882, 43.572260463173905, 42.652473745366095, 44.73117738740471  …  45.344847955738516, 44.34027703421765, 43.623696133471206, 44.85192018826672, 44.94588021728907, 43.06890282907216, 43.20983432421144, 42.03776896932048, 43.400305159946086, 43.68847321710271], κ = Gaussian kinetic energy (Diagonal), √diag(M⁻¹): [0.014998133836119898, 0.0062653703887802425, 0.286610928834639, 0.28806285936408904], ϵ = 0.5145953763055529)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Bayesian Inference of ODE</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 12 January 2026 20:38">Monday 12 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
